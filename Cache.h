///////////////////////////////////////////// ///////////////////
# pragma once
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
# include "defs.h"
# include <unordered_map>
# include <array>
# include <mutex>
# include <shared_mutex>
////////////////////////////////////////////////////////////////
using std::array;
using std::unordered_map;
using std::shared_mutex;
using std::lock_guard;
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
namespace cache {
////////////////////////////////////////////////////////////////
constexpr int MAXDEPTH = 8;
constexpr int BUCKET_COUNT = 64;
////////////////////////////////////////////////////////////////
typedef u64 Key;
typedef array <u64, MAXDEPTH> Value;
////////////////////////////////////////////////////////////////
class Perft {
public:
    static u64 get( Key hash, int depth ){
        lock_guard <shared_mutex> lock( mutx );
        return umap[ hash ][ depth ];
    }
    static void set( Key hash, int depth, u64 n ){
        lock_guard <shared_mutex> lock( mutx );
        umap[ hash ][ depth ] = n;
    }
private:
    static unordered_map <Key,Value> umap;
    static shared_mutex mutx;
};
////////////////////////////////////////////////////////////////
class ConcurrentPerft {//                              [ CGPT4 ]
    static array <unordered_map <Key, Value>, BUCKET_COUNT> buckets;
    static array <shared_mutex, BUCKET_COUNT> mutexes;
    static int get_bucket_index( const Key& key ){
        return key % BUCKET_COUNT;
    }
public:
    static u64 get( Key hash, int depth ){
        int bucket_idx = get_bucket_index( hash );
        lock_guard <shared_mutex> lock( mutexes[ bucket_idx ]);
        auto& bucket = buckets[ bucket_idx ];
        return bucket[ hash ][ depth ];
    }
    static void set( Key hash, int depth, u64 n ){
        int bucket_idx = get_bucket_index( hash );
        lock_guard <shared_mutex> lock( mutexes[ bucket_idx ]);
        auto& bucket = buckets[ bucket_idx ];
        bucket[ hash ][ depth ] = n;
    }
};
}
////////////////////////////////////////////////////////////////
using PerftCache = cache::ConcurrentPerft;
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// N6K/8/5N2/n7/8/6n1/8/k7 b - - 0 1
// > perft 7
// 8.34398 sec
// Perft: 80710893
// 5.89185 sec with Setoff
// 5.57156 sec with Figure::Hash
